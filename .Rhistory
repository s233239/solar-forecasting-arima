layout(rbind(1,2:3))
par(mar=c(3,3,1,1), mgp=c(2, 0.7,0))
plot(x, ylab="X")
acf(x, lag.max=50, lwd=2)
pacf(x, lag.max=50, lwd=2)
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
n <- 200 # number of observations
# Create a dataframe to store the realizations
ar_data <- data.frame(
time = 1:n
)
# # Create a dataframe to store the confidence intervals
# ci_data <- data.frame(
#   time = 1:n
# )
# Simulate 5 realizations and plot each
for (i in 1:5) {
col_name <- paste0("Realization ", i)  # column name
ar_data[col_name] <- rep(0, n)  # to keep the data of our AR simulated processes
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data[col_name] <- arima.sim(model, n) # simulate an AR process
#ci_data[col_name] <- confint(ar_data[col_name])
plotit( ar_data[col_name] )     # plot the realization
}
# Resizing the graphics window
par(mfrow=c(1,1))
# Plot in one plot
matplot(ar_data$time, ar_data[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = −0.7 and ϕ2 = −0.2", ylim = range(ar_data[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
## ---------------------------------------------------------------------------------------
## 1.6. Calculate the empirical ACF of the simulations and plot them together with ρ(k), up to lag 30.
# Calculate the empirical autocorrelation for each realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data[col_name] <- acf(ar_data[col_name], lag.max = nlag, plot = FALSE)$acf
}
# # Plot autocorrelation for each model on a single bar plot
# acf_mat <- as.matrix(acf_data[, -1])  # Excluding the first column
#
# # Generating different colors for each plot
# colors <- c("green", "blue", "purple", "red", "orange", "black")
#
# barplot(t(acf_mat), names.arg = acf_data$time, beside = TRUE, col = colors, border=NA, space=c(0.5,5),
#         xlab = "Time", ylab = "Value", main = "Autocorrelation Plot for ϕ1 = −0.7 and ϕ2 = −0.2")
# legend("topright", legend = colnames(acf_mat), col = colors, lwd = 2)
# Plot on a line plot
matplot(acf_data$time, acf_data[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = −0.7 and ϕ2 = −0.2", ylim = range(acf_data[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
# # Add the confidence interval
# acf_data$CI <- rep(qnorm(0.975), nlag+1)
# lines(acf_data$time, acf_data$CI, type = "l", lwd = 2, lty = 2,col="red")
# y_min <- min(acf_data[,-1])
# y_max <- max(acf_data[,-1])
#
# plot(acf_data$time, acf_data$rho, type = "l", col = colors[1], lty = 1, ylim = c(y_min, y_max),
#      xlab = "Time", ylab = "Value", main = "Autocorrelation Plot")
#
# for (i in 1:5) {
#   lines(acf_data$time, acf_mat[,i+1], type = "l", col = colors[i+1])
# }
# legend("topright", legend = colnames(acf_mat), col = colors, lwd = 2)
## ---------------------------------------------------------------------------------------
## 1.7. Redo plots of simulations and ACFs for the following ϕ1-values.
## ϕ1 = −0.2
phi1 <- -0.2
ar_data2 <- data.frame( time = 1:n )
acf_data2 <- data.frame( time = 0:nlag,
rho = rep(0, nlag+1) )
# Base cases of the recursive formula
acf_data2$rho[1] <- 1
acf_data2$rho[2] <- -phi1 / (1+phi2)
# Calculate recursively ρ(k)
for (i in 3:(nlag+1)){
acf_data2$rho[i] <- -phi1*acf_data2$rho[i-1] - phi2*acf_data2$rho[i-2]
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
# Simulate 5 realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
ar_data2[col_name] <- rep(0, n)
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data2[col_name] <- arima.sim(model, n) # simulate an AR process
plotit(ar_data2[col_name])
}
# Resizing the graphics window
par(mfrow=c(1,1))
# Plot the realizations
matplot(ar_data2$time, ar_data2[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = −0.2", ylim = range(ar_data2[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
# Calculate the empirical autocorrelation for each realization
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data2[col_name] <- acf(ar_data2[col_name], lag.max = nlag, plot = FALSE)$acf
}
# Plot the auto correlations on a line plot
matplot(acf_data2$time, acf_data2[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = −0.2", ylim = range(acf_data2[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
# # On a  bar plot
# acf_mat2 <- as.matrix(acf_data2[, -1])
# barplot(t(acf_mat2), names.arg = acf_data2$time, beside = TRUE, col = colors, border=NA, space=c(0.5,5),
#         xlab = "Time", ylab = "Value", main = "Autocorrelation Plot for ϕ1 = −0.2")
# legend("topright", legend = colnames(acf_mat2), col = colors, lwd = 2)
## ---------------------------------------------------------------------------------------
## 1.8. Redo plots of simulations and ACFs for the following ϕ1-values.
## ϕ1 = 0.7
phi1 <- 0.7
ar_data2 <- data.frame( time = 1:n )
acf_data2 <- data.frame( time = 0:nlag,
rho = rep(0, nlag+1) )
# Base cases of the recursive formula
acf_data2$rho[1] <- 1
acf_data2$rho[2] <- -phi1 / (1+phi2)
# Calculate recursively ρ(k)
for (i in 3:(nlag+1)){
acf_data2$rho[i] <- -phi1*acf_data2$rho[i-1] - phi2*acf_data2$rho[i-2]
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
# Simulate 5 realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
ar_data2[col_name] <- rep(0, n)
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data2[col_name] <- arima.sim(model, n) # simulate an AR process
plotit(ar_data2[col_name])
}
# Resizing the graphics window
par(mfrow=c(1,1))
# Plot the realizations
matplot(ar_data2$time, ar_data2[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = 0.7", ylim = range(ar_data2[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
# Calculate the empirical autocorrelation for each realization
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data2[col_name] <- acf(ar_data2[col_name], lag.max = nlag, plot = FALSE)$acf
}
# Plot the auto correlations on a line plot
matplot(acf_data2$time, acf_data2[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = 0.7", ylim = range(acf_data2[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
## ---------------------------------------------------------------------------------------
## NON-STATIONARY PROCESSES
## ---------------------------------------------------------------------------------------
# A simulation function for ARMA simulation, use model as arima.sim, i.e. flip sign of phi (into ar) coefficients
sim <- function(model, n, nburnin=100){
n <- n + nburnin
# Take the ar and ma part
ar <- model$ar
ma <- model$ma
# The order (i.e. the number of lags)
p <- length(ar)
q <- length(ma)
# The vector for the simulation result
y <- numeric(n)
# Generate the random normal values
eps <- rnorm(n)
# Run the simulation
for(i in (max(p,q)+1):n){
y[i] <- eps[i] + sum(y[i-(1:p)] * ar) + sum(eps[i-(1:q)] * ma)
}
# Return without the burn-in period
return(y[(nburnin+1):n])
}
## ---------------------------------------------------------------------------------------
## 1.9. Redo plots of simulations and ACFs for the following ϕ1-values.
## ϕ1 = −0.8
# Initialize
phi1 <- -0.8
ar_data2 <- data.frame( time = 1:n )
acf_data2 <- data.frame( time = 0:nlag,
rho = rep(0, nlag+1) )
# Base cases of the recursive formula
acf_data2$rho[1] <- 1
acf_data2$rho[2] <- -phi1 / (1+phi2)
# Calculate recursively ρ(k)
for (i in 3:(nlag+1)){
acf_data2$rho[i] <- -phi1*acf_data2$rho[i-1] - phi2*acf_data2$rho[i-2]
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
# Simulate 5 realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
ar_data2[col_name] <- rep(0, n)
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data2[col_name] <- sim(model, n) # simulate a non-stationnary AR process
}
# Plot the realizations
matplot(ar_data2$time, ar_data2[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = −0.8", ylim = range(ar_data2[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
# Calculate the empirical autocorrelation for each realization
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data2[col_name] <- acf(ar_data2[col_name], lag.max = nlag, plot = FALSE)$acf
}
# Plot the auto correlations on a line plot
matplot(acf_data2$time, acf_data2[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = −0.8", ylim = range(acf_data2[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
## ---------------------------------------------------------------------------------------
## 1.10. Redo plots of simulations and ACFs for the following ϕ1-values.
## ϕ1 = −0.85
phi1 <- -0.85
ar_data2 <- data.frame( time = 1:n )
acf_data2 <- data.frame( time = 0:nlag,
rho = rep(0, nlag+1) )
# Base cases of the recursive formula
acf_data2$rho[1] <- 1
acf_data2$rho[2] <- -phi1 / (1+phi2)
# Calculate recursively ρ(k)
for (i in 3:(nlag+1)){
acf_data2$rho[i] <- -phi1*acf_data2$rho[i-1] - phi2*acf_data2$rho[i-2]
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
# Simulate 5 realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
ar_data2[col_name] <- rep(0, n)
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data2[col_name] <- sim(model, n) # simulate a non-stationary AR process
}
# Plot the realizations
matplot(ar_data2$time, ar_data2[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = −0.85", ylim = range(ar_data2[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
# Calculate the empirical autocorrelation for each realization
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data2[col_name] <- acf(ar_data2[col_name], lag.max = nlag, plot = FALSE)$acf
}
# Plot the auto correlations on a line plot
matplot(acf_data2$time, acf_data2[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = −0.85", ylim = range(acf_data2[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
phi1 <- 0.7
phi2 <- 0.2
ar_data2 <- data.frame( time = 1:n )
acf_data2 <- data.frame( time = 0:nlag,
rho = rep(0, nlag+1) )
# Base cases of the recursive formula
acf_data2$rho[1] <- 1
acf_data2$rho[2] <- -phi1 / (1+phi2)
# Calculate recursively ρ(k)
for (i in 3:(nlag+1)){
acf_data2$rho[i] <- -phi1*acf_data2$rho[i-1] - phi2*acf_data2$rho[i-2]
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
# Simulate 5 realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
ar_data2[col_name] <- rep(0, n)
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data2[col_name] <- arima.sim(model, n) # simulate an AR process
plotit(ar_data2[col_name])
}
# Resizing the graphics window
par(mfrow=c(1,1))
# Plot the realizations
matplot(ar_data2$time, ar_data2[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = 0.7", ylim = range(ar_data2[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
# Calculate the empirical autocorrelation for each realization
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data2[col_name] <- acf(ar_data2[col_name], lag.max = nlag, plot = FALSE)$acf
}
# Plot the auto correlations on a line plot
matplot(acf_data2$time, acf_data2[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = 0.7", ylim = range(acf_data2[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
phi1 <- 0.7
phi2 <- -0.2
ar_data2 <- data.frame( time = 1:n )
acf_data2 <- data.frame( time = 0:nlag,
rho = rep(0, nlag+1) )
# Base cases of the recursive formula
acf_data2$rho[1] <- 1
acf_data2$rho[2] <- -phi1 / (1+phi2)
# Calculate recursively ρ(k)
for (i in 3:(nlag+1)){
acf_data2$rho[i] <- -phi1*acf_data2$rho[i-1] - phi2*acf_data2$rho[i-2]
}
# AR(2) process
model <- list(ar=c(-phi1, -phi2))
# Simulate 5 realizations
for (i in 1:5) {
col_name <- paste0("Realization ", i)
ar_data2[col_name] <- rep(0, n)
(seed_name <- paste0(i,i+1,i+2))    # set seed for simulation of process
set.seed(seed_name)
ar_data2[col_name] <- arima.sim(model, n) # simulate an AR process
plotit(ar_data2[col_name])
}
# Resizing the graphics window
par(mfrow=c(1,1))
# Plot the realizations
matplot(ar_data2$time, ar_data2[, -1], type = "l", lty = 1, col = 1:5, xlab = "Time", ylab = "Value",
main = "Simulated processes for ϕ1 = 0.7", ylim = range(ar_data2[, -1]))
legend("topright", legend = colnames(ar_data[, -1]), col = 1:5, lty = 1, cex = 0.8)
# Calculate the empirical autocorrelation for each realization
for (i in 1:5) {
col_name <- paste0("Realization ", i)
acf_data2[col_name] <- acf(ar_data2[col_name], lag.max = nlag, plot = FALSE)$acf
}
# Plot the auto correlations on a line plot
matplot(acf_data2$time, acf_data2[,-1], type = c("h", rep("l", 5)), lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), col = 1:5, xlab = "Time", ylab = "Value",
main = "Autocorrelation Plot for ϕ1 = 0.7", ylim = range(acf_data2[, -1]))
legend("topright", legend = c("Theoretical ACF", paste(colnames(acf_data[,-1][,-1]),"ACF")), col = 1:5, lty = c(1,rep(1,5)), lwd = c(2,rep(1,5)), cex = 0.8)
# load excel read library
library(utils)
library(ggplot2)
library(xtable)
# clear variables
rm(list=ls())
# resizing the graphics window
par(mfrow=c(1,1))
## ---------------------------------------------------------------------------------------
## Part 3 - Simulating seasonal processes
## Simulate the following models.
## Plot the simulations and the associated autocorrelation functions (ACF and PACF).
# Function for plot
plotit <- function(x, tit=NA){
layout(rbind(1,2:3))
par(mar=c(3,3,1,1), mgp=c(2, 0.7,0))
plot(x, type="l", ylab="X", xlab="Time")
title(main=tit)
acf(x, lag.max=50, lwd=2)
pacf(x, lag.max=50, lwd=2)
}
# A simulation function for ARMA simulation, use model as arima.sim, i.e. flip sign of phi (into ar) coefficients
sim <- function(model, n, nburnin=100){
n <- n + nburnin
# Take the ar and ma part
ar <- model$ar
ma <- model$ma
# The order (i.e. the number of lags)
p <- length(ar)
q <- length(ma)
# The vector for the simulation result
y <- numeric(n)
# Generate the random normal values
eps <- rnorm(n)
# Run the simulation
for(i in (max(p,q)+1):n){
y[i] <- eps[i] + sum(y[i-(1:p)] * ar) + sum(eps[i-(1:q)] * ma)
}
# Return without the burn-in period
return(y[(nburnin+1):n])
}
# Set a fixed seed for all of our simulations
set.seed(42)
# load excel read library
library(utils)
library(ggplot2)
library(xtable)
# clear variables
rm(list=ls())
# resizing the graphics window
par(mfrow=c(1,1))
## ---------------------------------------------------------------------------------------
## Part 3 - Simulating seasonal processes
## Simulate the following models.
## Plot the simulations and the associated autocorrelation functions (ACF and PACF).
# Function for plot
plotit <- function(x, tit=NA){
layout(rbind(1,2:3))
par(mar=c(3,3,1,1), mgp=c(2, 0.7,0))
plot(x, type="l", ylab="X", xlab="Time")
title(main=tit)
acf(x, lag.max=50, lwd=2)
pacf(x, lag.max=50, lwd=2)
}
# A simulation function for ARMA simulation, use model as arima.sim, i.e. flip sign of phi (into ar) coefficients
sim <- function(model, n, nburnin=100){
n <- n + nburnin
# Take the ar and ma part
ar <- model$ar
ma <- model$ma
# The order (i.e. the number of lags)
p <- length(ar)
q <- length(ma)
# The vector for the simulation result
y <- numeric(n)
# Generate the random normal values
eps <- rnorm(n)
# Run the simulation
for(i in (max(p,q)+1):n){
y[i] <- eps[i] + sum(y[i-(1:p)] * ar) + sum(eps[i-(1:q)] * ma)
}
# Return without the burn-in period
return(y[(nburnin+1):n])
}
# Set a fixed seed for all of our simulations
set.seed(42)
## ---------------------------------------------------------------------------------------
## 3.1. A (1,0,0)×(0,0,0)12 model with the parameter ϕ1 = 0.6
# AR(1) process
phi <- c(0.6)
model <- list(ar=-phi)
# Number of observations of our simulation, high enough to not have a lot of noise
n <- 1000
# Simulate 1 realization and plot it with its ACFs
plotit( arima.sim(model, n), "A (1,0,0)×(0,0,0)12 with ϕ1 = 0.6" )
#plotit( sim(model, n), "A (1,0,0)×(0,0,0)12 with ϕ1 = 0.6" )
############
# Plot the autocorrelation function (theory)
ar1_data <- data.frame(
lag = 0:50
)
ar1_data$acf <- (-phi)^(ar1_data$lag)
par(mfrow=c(1,1))
acf(arima.sim(model, n))
lines(ar1_data$lag ,ar1_data$acf, type="l",col="red", lty=2, lwd=2)
## ---------------------------------------------------------------------------------------
## 3.2. A (0,0,0)×(1,0,0)12 model with the parameter Φ1 = −0.9
# AR(12) process with Φi = 0 for i=1,...11 and Φ12 = −0.9
phi <- c(rep(0,11),-0.9)
model <- list(ar=-phi)
# Number of observations of our simulation, high enough to not have a lot of noise
n <- 1000
# Simulate 1 realization and plot it with its ACFs
plotit( arima.sim(model, n), "A (0,0,0)×(1,0,0)12 with Φ1 = −0.9" )
#plotit( sim(model, n), "A (0,0,0)×(1,0,0)12 with Φ1 = −0.9" )
############
# Plot the autocorrelation function (theory)
ar12_data <- data.frame(
lag = 0:50,
acf = rep(0,51)
)
for (k in 0:(as.integer(50/12))){
ar12_data$acf[12*k+1] <- (-phi[12])^k
}
par(mfrow=c(1,1))
acf(arima.sim(model, n))
lines(ar12_data$lag ,ar12_data$acf, type="l",col="red", lty=2, lwd=2)
## ---------------------------------------------------------------------------------------
## 3.3. A (1,0,0)×(0,0,1)12 model with the parameters ϕ1 = 0.9 and Θ1 = −0.7
# ARMA(1,12) process with ϕ1 = 0.9, θi = 0 for i=1,...11 and θ12 = −0.7
phi <- c(0.9)
theta <- c(rep(0,11),-0.7)
model <- list(ar=-phi, ma=theta)
# Number of observations of our simulation, high enough to not have a lot of noise
n <- 1000
# Simulate 1 realization and plot it with its ACFs
plotit( arima.sim(model, n), "A (1,0,0)×(0,0,1)12 with ϕ1 = 0.9 and Θ1 = −0.7" )
#plotit( sim(model, n), "A (1,0,0)×(0,0,1)12 with ϕ1 = 0.9 and Θ1 = −0.7" )
abs(polyroot(c(-0.2,-0.7,1)))
abs(polyroot(c(0.48,-0.8,rep(0,10),-0.6,1)))
library('sarima')
plotit <- function(x){
layout(rbind(1,2:3))
par(mar=c(3,3,1,1), mgp=c(2, 0.7,0))
plot(x, ylab=expression(Y[t]),xlab="Time", type="l")
acf(x, lag.max=50, lwd=2)
pacf(x, lag.max=50, lwd=2)
}
# 3.1 AR(1)
set.seed(42)
Y = sim_sarima(n=5000, model = list(ar = 0.6, nseasons = 12))
plotit(Y[1:500])
# 3.1 AR(1)
set.seed(42)
Y = sim_sarima(n=5000, model = list(ar = -0.6, nseasons = 12))
plotit(Y[1:500])
# 3.2 seasonal AR(1)
set.seed(42)
Y = sim_sarima(n=5000, model = list(sar = 0.9, nseasons = 12))
plotit(Y[1:500])
# 3.3
set.seed(42)
Y = sim_sarima(n=5000, model = list(ar = -0.9, sma = -0.7,  nseasons = 12))
plotit(Y[1:500])
# 3.4
set.seed(42)
Y = sim_sarima(n=5000, model = list(ar = 0.6, sar = 0.8,  nseasons = 12))
plotit(Y[1:500])
# 3.4
set.seed(42)
Y = sim_sarima(n=10000, model = list(ar = 0.6, sar = 0.8,  nseasons = 12))
plotit(Y[1:500])
# 3.4
set.seed(42)
Y = sim_sarima(n=100000, model = list(ar = 0.6, sar = 0.8,  nseasons = 12))
plotit(Y[1:500])
# 3.5
set.seed(42)
Y = sim_sarima(n=5000, model = list(ma = 0.4, sma = -0.8,  nseasons = 12))
plotit(Y[1:500])
# 3.6
set.seed(42)
Y = sim_sarima(n=5000, model = list(ma = -0.4, sar = -0.7,  nseasons = 12))
plotit(Y[1:500])
(polyroot(c(0.48,-0.8,rep(0,10),-0.6,1)))
abd(polyroot(c(0.48,-0.8,rep(0,10),-0.6,1)))
abs(polyroot(c(0.48,-0.8,rep(0,10),-0.6,1)))
